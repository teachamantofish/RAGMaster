
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RAG Workflow Configuration</title>
  <!-- Shoelace CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.11.0/cdn/themes/light.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.11.0/cdn/themes/dark.css">
  <link rel="stylesheet" href="style.css">
  <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.11.0/cdn/shoelace.js"></script>
  <script type="module" src="./vite/src/main.ts"></script> <!-- or .js -->
  <script type="module">
    const initThemeToggle = () => {
      const toggle = document.getElementById('theme-toggle');
      if (!toggle) return;

      // Optional: start in light mode
      document.body.classList.remove('sl-theme-dark');

      toggle.addEventListener('sl-change', e => {
        const isDark = e.target.checked;
        document.body.classList.toggle('sl-theme-dark', isDark);
      });
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initThemeToggle, { once: true });
    } else {
      initThemeToggle();
    }
  </script>
</head>
<body>
  <header class="header">
    <div class="header-title">RAG Workflow Configuration</div>
    <div class="header-xyz"></div>
    <sl-switch id="theme-toggle" class="theme-toggle" checked>Light/Dark</sl-switch>
  </header>

  <main class="main">    
    <sl-tab-group id="workflow-tabs">
      <sl-tab slot="nav" panel="source">RAG Feeds</sl-tab>
      <sl-tab slot="nav" panel="crawl">Crawl Web</sl-tab>
      <sl-tab slot="nav" panel="crawl_pdf">Crawl PDF</sl-tab>
      <sl-tab slot="nav" panel="clean">Clean</sl-tab>
      <sl-tab slot="nav" panel="chunk">Chunk</sl-tab>
      <sl-tab slot="nav" panel="summary">Summarize</sl-tab>
      <sl-tab slot="nav" panel="embed">Embed</sl-tab>
      <sl-tab slot="nav" panel="vector">Upload to Vector DB</sl-tab>
      <sl-tab-panel name="source">
        <section id="tab-content-source"></section>
      </sl-tab-panel>
      <sl-tab-panel name="crawl">
        <section id="tab-content-crawl"></section>
      </sl-tab-panel>
        <sl-tab-panel name="crawl_pdf">
          <section id="tab-content-crawl_pdf"></section>
        </sl-tab-panel>
      <sl-tab-panel name="clean">
        <section id="tab-content-clean"></section>
      </sl-tab-panel>
      <sl-tab-panel name="chunk">
        <section id="tab-content-chunk"></section>
      </sl-tab-panel>
      <sl-tab-panel name="summary">
        <section id="tab-content-summary"></section>
      </sl-tab-panel>
      <sl-tab-panel name="embed">
        <section id="tab-content-embed"></section>
      </sl-tab-panel>
      <sl-tab-panel name="vector">
        <section id="tab-content-vector"></section>
      </sl-tab-panel>
    </sl-tab-group>
</main>
</body>
<script type="module" src="js/app-config.js"></script>
<script src="js/datatables.js"></script>
<script src="js/util.js"></script>
<script>
// Tab file mapping
const tabFiles = {
  source: 'source.html',
  crawl: 'crawl.html',
  crawl_git: 'crawl_git.html',
  crawl_pdf: 'crawl_pdf.html',
  clean: 'clean.html',
  chunk: 'chunk.html',
  summary: 'summary.html',
  embed: 'embed.html',
  vector: 'vector.html'
};

// Python config file mapping for each tab
const tabConfigFiles = {
  crawl: '../pipeline/config/crawlconfig.py',
  crawl_pdf: '../pipeline/config/crawlpdfconfig.py',
  clean: '../pipeline/config/cleanconfig.py',
  chunk: '../pipeline/config/chunkerconfig.py',
  summary: '../pipeline/config/summaryconfig.py',
  embed: '../pipeline/config/embedconfig.py',
  vector: '../pipeline/config/vectorconfig.py'
};

// Which tabs should attempt to auto-load a config file.
// By default derive from the keys of tabConfigFiles so only tabs
// that have a mapped config will be auto-loaded. Exclude 'source'
// because the Source tab loads an HTML fragment that renders its
// own data table (no textarea/pywebview load required).
const configTabsToAutoLoad = Object.keys(tabConfigFiles).filter(t => t !== 'source');
const isHttpProtocol = window.location.protocol === 'http:' || window.location.protocol === 'https:';
const userAgent = typeof navigator !== 'undefined' ? (navigator.userAgent || '').toLowerCase() : '';
const detectedPywebviewUA = userAgent.includes('pywebview');
const detectedPywebviewGlobal = typeof pywebview !== 'undefined';

const PYWEBVIEW_MAX_ATTEMPTS = 6;
const PYWEBVIEW_RETRY_DELAY = 400;

window.__PYWEBVIEW_RUNTIME__ = detectedPywebviewUA || detectedPywebviewGlobal || window.__PYWEBVIEW_RUNTIME__ === true;
window.__PYWEBVIEW_MAX_ATTEMPTS__ = PYWEBVIEW_MAX_ATTEMPTS;
window.__PYWEBVIEW_RETRY_DELAY__ = PYWEBVIEW_RETRY_DELAY;

window.addEventListener('pywebviewready', () => {
  window.__PYWEBVIEW_RUNTIME__ = true;
});

function hasPywebviewApi() {
  return typeof pywebview !== 'undefined' &&
    pywebview &&
    pywebview.api &&
    typeof pywebview.api.load_file === 'function';
}

function isPywebviewRuntime() {
  return window.__PYWEBVIEW_RUNTIME__ === true;
}

// Source tab helpers are defined in web/js/datatables.js

function resolvePathForHttp(path) {
  if (/^(?:https?:)?\/\//.test(path)) return path;
  if (path.startsWith('/')) return path;
  if (isHttpProtocol) {
    return new URL(path, window.location.href).pathname;
  }
  return path;
}

function loadTab(tab) {
  const file = tabFiles[tab];
  const sectionId = `tab-content-${tab}`;
  const section = document.getElementById(sectionId);
  
  if (!file) return;

  const fileUrl = (() => {
    if (/^(?:https?:)?\/\//.test(file)) return file;
    if (file.startsWith('/')) return file;
    if (window.location.protocol === 'file:') return file;
    return `/${file.replace(/^\.\//, '')}`;
  })();
  
  // Only fetch HTML if the section is empty (not already loaded)
  if (!section.innerHTML.trim()) {
    fetch(fileUrl)
      .then(response => {
        if (!response.ok) throw new Error(`Failed to fetch ${fileUrl}: ${response.status}`);
        return response.text();
      })
      .then(html => {
        const looksLikeDocument = /<!doctype/i.test(html) || /<html[\s>]/i.test(html);
        if (looksLikeDocument) {
          console.error(`Expected fragment but received full document from ${fileUrl}. Check dev server settings or path.`);
          section.innerHTML = `<div style="color:#c00">Unexpected document response from ${fileUrl}. Check the dev server configuration.</div>`;
          return;
        }
        // Insert the HTML fragment
        section.innerHTML = html;
        if (tab === 'source') {
          sourceTabState.initialized = false;
          sourceTabState.waitAttempts = 0;
        }

        // Execute any <script> tags found in the fragment.
        // Strategy: load external scripts sequentially (skip if already present),
        // then execute inline scripts in order.
        const scripts = Array.from(section.querySelectorAll('script'));
        const external = scripts.filter(s => s.src);
        const inline = scripts.filter(s => !s.src);

        // Remove original script tags from the fragment to avoid duplication
        scripts.forEach(s => s.parentNode && s.parentNode.removeChild(s));

        function loadExternalSequential(list, cb) {
          if (!list.length) return cb();
          const s = list.shift();
          const src = s.getAttribute('src');
          // Skip if already present on the page
          if (document.querySelector(`script[src="${src}"]`)) {
            return loadExternalSequential(list, cb);
          }
          const tag = document.createElement('script');
          if (s.type) tag.type = s.type;
          tag.src = src;
          tag.async = false;
          tag.onload = () => loadExternalSequential(list, cb);
          tag.onerror = () => {
            console.error('Failed to load script', src);
            loadExternalSequential(list, cb);
          };
          document.head.appendChild(tag);
        }

        loadExternalSequential(external.slice(), () => {
          // If running inside pywebview, preload the CSV via the pywebview API
          // and set it on a global variable that the fragment can read.
          (async function preparePywebviewPreload() {
            if (hasPywebviewApi()) {
              try {
                const sourceTable = window.SourceTable;
                const defaults = sourceTable && typeof sourceTable.getConfig === 'function'
                  ? sourceTable.getConfig()
                  : (sourceTable && sourceTable.defaults) || {};
                let configPath = defaults.csvPath || null;
                let preloadKey = defaults.preloadedKey || null;

                if (window.AppConfig && typeof window.AppConfig.ready === 'function') {
                  try {
                    await window.AppConfig.ready();
                    const metadataConfig = window.AppConfig.get('source.metadata');
                    if (metadataConfig) {
                      if (metadataConfig.csvPath) configPath = metadataConfig.csvPath;
                      if (metadataConfig.preloadedKey) preloadKey = metadataConfig.preloadedKey;
                    }
                  } catch (configErr) {
                    console.warn('[pywebview] unable to resolve Source tab config from AppConfig', configErr);
                  }
                }

                if (!preloadKey && configPath) {
                  const inferred = configPath.split(/[\\/]/).pop();
                  preloadKey = inferred || null;
                }


                if (configPath) {
                  const result = await pywebview.api.load_file(configPath);
                  if (result && result.success && typeof result.content === 'string') {
                    window.__PRELOADED_FILES = window.__PRELOADED_FILES || {};
                    if (preloadKey) {
                      window.__PRELOADED_FILES[preloadKey] = result.content;
                      console.log(`[pywebview] preloaded ${preloadKey} into window.__PRELOADED_FILES`);
                    }
                  } else {
                    console.warn('[pywebview] load_file returned no content or an error', result && result.error);
                  }
                }
              } catch (err) {
                console.warn('[pywebview] failed to preload Source tab CSV via API', err);
              }
            }

            // Execute inline scripts after pywebview preload is prepared
            inline.forEach(s => {
              const tag = document.createElement('script');
              if (s.type) tag.type = s.type;
              tag.text = s.textContent;
              document.body.appendChild(tag);
            });

            // Initialize summary/crawl/source handlers if needed
            if (tab === 'summary') setTimeout(initializeSummaryToggle, 100);
            if (tab === 'crawl') setTimeout(initializeCrawlToggle, 100);
            if (tab === 'source') setTimeout(() => loadSourceTab(), 50);
          })();
        });
      })
      .catch(err => {
        console.error(err);
        section.innerHTML = `<div style="color:#c00">Error loading ${file}: ${err.message}</div>`;
      });
  }
}

// Toggle between Local and HuggingFace fields in summary tab
function initializeSummaryToggle() {
  const modelBackendRadio = document.getElementById('model_backend');
  if (!modelBackendRadio) {
    console.log('Radio group not found');
    return;
  }
  
  function toggleFields() {
    const selectedValue = modelBackendRadio.value;
    console.log('Selected backend:', selectedValue);
    
    const localFields = document.querySelectorAll('.local-fields');
    const hfFields = document.querySelectorAll('.hf-fields');
    
    console.log('Local fields found:', localFields.length);
    console.log('HF fields found:', hfFields.length);
    
    if (selectedValue === 'huggingface') {
      // Hide local fields, show HF fields
      localFields.forEach(field => field.style.display = 'none');
      hfFields.forEach(field => field.style.display = 'block');
    } else {
      // Show local fields, hide HF fields
      localFields.forEach(field => field.style.display = 'block');
      hfFields.forEach(field => field.style.display = 'none');
    }
  }
  
  console.log('Attaching event listener to model backend radio');
  modelBackendRadio.addEventListener('sl-change', toggleFields);
  toggleFields(); // Initialize
}

// Toggle between Web and GIT crawl fields
function initializeCrawlToggle() {
  const crawlTypeRadio = document.getElementById('crawl_type');
  if (!crawlTypeRadio) {
    console.log('Crawl type radio group not found');
    return;
  }
  
  function toggleFields() {
    const selectedValue = crawlTypeRadio.value;
    console.log('Selected crawl type:', selectedValue);
    
    const webFields = document.querySelectorAll('.web-fields');
    const gitFields = document.querySelectorAll('.git-fields');
    
    console.log('Web fields found:', webFields.length);
    console.log('GIT fields found:', gitFields.length);
    
    if (selectedValue === 'git') {
      // Hide web fields, show GIT fields
      webFields.forEach(field => field.style.display = 'none');
      gitFields.forEach(field => field.style.display = 'block');
    } else {
      // Show web fields, hide GIT fields
      webFields.forEach(field => field.style.display = 'block');
      gitFields.forEach(field => field.style.display = 'none');
    }
  }
  
  console.log('Attaching event listener to crawl type radio');
  crawlTypeRadio.addEventListener('sl-change', toggleFields);
  toggleFields(); // Initialize
}

// API functions for loading config files
async function loadConfigForTab(tabName, attempt = 0) {
    console.log(`[DEBUG] Starting loadConfigForTab for: ${tabName} (attempt ${attempt + 1})`);
    
    console.log(`[DEBUG] Looking for ${tabName}config first...`);
    let statusDisplay = document.getElementById(`${tabName}config`);
    if (!statusDisplay) {
        console.log(`[DEBUG] ${tabName}config not found, trying status-display...`);
        statusDisplay = document.getElementById('status-display');
    }
    if (!statusDisplay && tabName === 'crawl') {
        console.log(`[DEBUG] Also trying crawlconfig for crawl tab...`);
        statusDisplay = document.getElementById('crawlconfig');
    }
    
    if (!statusDisplay) {
        console.log(`[DEBUG] No textarea found for ${tabName}, waiting...`);
        setTimeout(() => loadConfigForTab(tabName), 500);
        return;
    }
    
    console.log(`[DEBUG] Found textarea element: ${statusDisplay.id}`);
    
    const configFile = tabConfigFiles[tabName];
    console.log(`[DEBUG] Config file mapping for ${tabName}: ${configFile}`);
    if (!configFile) {
        console.log(`[ERROR] No config file defined for tab: ${tabName}`);
        statusDisplay.value = `No config file defined for ${tabName} tab`;
        return;
    }
    
    statusDisplay.placeholder = `Loading ${configFile}...`;
    console.log(`[DEBUG] Set placeholder, now attempting to load...`);
    
    const pywebviewRuntime = isPywebviewRuntime();
    const maxAttempts = window.__PYWEBVIEW_MAX_ATTEMPTS__ ?? PYWEBVIEW_MAX_ATTEMPTS;
    const retryDelay = window.__PYWEBVIEW_RETRY_DELAY__ ?? PYWEBVIEW_RETRY_DELAY;
    const hasPy = hasPywebviewApi();

    if (pywebviewRuntime && !hasPy && attempt < maxAttempts) {
        console.log('[DEBUG] pywebview runtime detected but API not ready. Retrying soon...');
        statusDisplay.placeholder = `Waiting for pywebview... (retry ${attempt + 2}/${maxAttempts + 1})`;
        setTimeout(() => loadConfigForTab(tabName, attempt + 1), retryDelay);
        return;
    }

    let loadedSuccessfully = false;
    let lastError = null;
    
    if (hasPy) {
        try {
            console.log(`[DEBUG] Calling pywebview.api.load_file(${configFile})`);
            const result = await pywebview.api.load_file(configFile);
            console.log(`[DEBUG] Load result:`, result);
            
            if (result && result.success) {
                statusDisplay.value = result.content;
                statusDisplay.placeholder = `${configFile} loaded successfully`;
                console.log(`[SUCCESS] File loaded for ${tabName}: ${configFile}`);
                loadedSuccessfully = true;
            } else {
                const errorDetail = result && result.error ? result.error : 'Unknown error';
                console.warn(`[WARN] pywebview load failed for ${configFile}: ${errorDetail}`);
                lastError = new Error(errorDetail);
            }
        } catch (error) {
            console.warn(`[WARN] pywebview load threw for ${configFile}:`, error);
            lastError = error;
        }
    }
    
    if (!loadedSuccessfully) {
        if (isHttpProtocol) {
            try {
                const configUrl = resolvePathForHttp(configFile);
                console.log(`[DEBUG] Fetching config via HTTP: ${configUrl}`);
                const response = await fetch(configUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const text = await response.text();
                statusDisplay.value = text;
                statusDisplay.placeholder = `${configFile} loaded successfully`;
                console.log(`[SUCCESS] File fetched for ${tabName}: ${configUrl}`);
                loadedSuccessfully = true;
            } catch (fetchError) {
                console.error(`[ERROR] Unable to fetch ${configFile}:`, fetchError);
                lastError = fetchError;
                if (pywebviewRuntime && attempt < maxAttempts) {
                    statusDisplay.placeholder = `Waiting for pywebview... (retry ${attempt + 2}/${maxAttempts + 1})`;
                    setTimeout(() => loadConfigForTab(tabName, attempt + 1), retryDelay);
                    return;
                }
            }
        } else if (!hasPy) {
            lastError = new Error('pywebview API not available and HTTP fetch unsupported for this protocol');
        }
    }
    
    if (!loadedSuccessfully) {
        const message = lastError ? lastError.message : 'Unknown failure';
        statusDisplay.value = `Failed to load ${configFile}: ${message}`;
        statusDisplay.placeholder = '';
    }
}

// Legacy functions for backward compatibility
async function testAPI() {
    return loadConfigForTab('crawl');
}

function reloadConfigFile() {
    // Determine which tab is currently active
    const activeTab = document.querySelector('sl-tab[active]');
    const tabName = activeTab ? activeTab.getAttribute('panel') : 'crawl';
    console.log(`Manually reloading config for tab: ${tabName}`);
    loadConfigForTab(tabName);
}

function initializeCrawlConfig() {
    console.log('Initializing crawl config...');
    setTimeout(() => loadConfigForTab('crawl'), 100);
}

// Listen for Shoelace tab change events
const workflowTabs = document.getElementById('workflow-tabs');
const getActivePanelName = target => {
  if (!target) return null;
  if (target.activeTab && target.activeTab.panel) return target.activeTab.panel;
  if (typeof target.getActiveTab === 'function') {
    const active = target.getActiveTab();
    if (active && active.panel) return active.panel;
  }
  return null;
};

const handleTabChange = event => {
  const detail = event.detail || {};
  const tab =
    detail.name ||
    (detail.tab && detail.tab.panel) ||
    (detail.panel && detail.panel.name) ||
    getActivePanelName(event.target);

  if (!tab) {
    console.warn('[WARN] Unable to resolve tab name from event', event);
    return;
  }

  loadTab(tab);
  if (tab === 'source') loadSourceTab();
  
  if (configTabsToAutoLoad.includes(tab)) {
    setTimeout(() => {
      loadConfigForTab(tab);
    }, 300);
  } else {
    console.log(`[DEBUG] Skipping config load for tab: ${tab}`);
  }
};

if (workflowTabs) {
  workflowTabs.addEventListener('sl-change', handleTabChange);
  workflowTabs.addEventListener('sl-tab-show', handleTabChange);
  window.addEventListener('pywebviewready', () => {
    const activePanel = getActivePanelName(workflowTabs);
    if (!activePanel) return;

    if (configTabsToAutoLoad.includes(activePanel)) {
      setTimeout(() => loadConfigForTab(activePanel), PYWEBVIEW_RETRY_DELAY);
    }

    if (activePanel === 'source') {
      setTimeout(() => loadSourceTab(true), PYWEBVIEW_RETRY_DELAY);
    }
  });
}

// Load the first tab by default
// Also preload the Source tab fragment so it doesn't wait for a user click
loadTab('source');
loadTab('crawl');
setTimeout(() => loadSourceTab(), 100);
// Also attempt to auto-load the default tab's config if it's in the list
if (configTabsToAutoLoad.includes('crawl')) {
  setTimeout(() => loadConfigForTab('crawl'), 300);
}
</script>
</html>

